const CLICKED_ITEMS = [
  {
    component: "",
    feature: ""
  },
  {
    component: "",
    action: ""
  }
];


class RoboArmComponents extends React.Component {
  render() {
    const componentKeys = Object.keys(this.props.componentConfig);
    const componentParts = componentKeys.map(componentName => (
      <Topology.Part
        a11yTitle={componentName}
        className="component"
        key={componentName}
        direction="row"
      >
        <RoboArmComponentFeatures
          featureConfig={this.props.componentConfig[componentName].features}
          componentName={componentName}
          onClickItem={this.props.onClickItem}
        />
        <Topology.Label className="raa_component_label">
          {componentName.toUpperCase()}
        </Topology.Label>
        <RoboArmControlFeatures
          featureConfig={this.props.componentConfig[componentName].features}
          controlName={componentName}
          onClickItem={this.props.onClickItem}
        />
      </Topology.Part>
    ));
    return (
      <Topology.Part
        a11yTitle="RoboArm Component Structure"
        className="RoboArmComponents"
        direction="column"
        label={this.props.roboArmName}
      >
        <Topology.Part
          a11yTitle="RoboArm Component Structure"
          className="raa_structure"
          direction="column"
          reverse={true}
        >
          {componentParts}
        </Topology.Part>
      </Topology.Part>
    );
  }
}

class RoboArmComponentFeatures extends React.Component {
  render() {
    const componentName = this.props.componentName;
    const featureKeys = Object.keys(this.props.featureConfig);
    const featureParts = featureKeys.map(featureName => (
      <Topology.Part
        id={componentName + "-" + featureName}
        status="ok"
        label={featureName}
        direction="row"
        demarcate={false}
        justify="start"
        align="center"
        key={featureName}
        className="raa_feature"
        reverse={true}
        onClick={this.props.onClickItem}
        data-id={componentName + "-" + featureName}
        data-type="componentFeature"
      />
    ));
    return (
      <Topology.Parts direction="column" uniform={true}>
        {featureParts}
      </Topology.Parts>
    );
  }
}

class RoboArmControlFeatures extends React.Component {
  render() {
    const featureDisplay = "all";
    const featureKeys = Object.keys(this.props.featureConfig);
    let displayFeatureKeys = [];
    if (featureKeys.length == 1) {
      displayFeatureKeys = featureKeys;
    } else {
      displayFeatureKeys = featureKeys.filter(
        feature => feature.indexOf(featureDisplay) > -1
      );
    }
    const featureParts = displayFeatureKeys.map(featureName => (
      <Topology.Part
        id={featureName}
        direction="column"
        demarcate={false}
        justify="start"
        align="start"
        key={featureName}
      >
        <RoboArmControlFeatureActions
          actionConfig={this.props.featureConfig[featureName].actions}
          featureName={featureName}
          controlName={this.props.controlName}
          onClickItem={this.props.onClickItem}
        />
      </Topology.Part>
    ));
    return (
      <Topology.Parts direction="column" uniform={true}>
        {featureParts}
      </Topology.Parts>
    );
  }
}

class RoboArmControlFeatureActions extends React.Component {
  render() {
    const featureName = this.props.featureName;
    const controlName = this.props.controlName;
    const actionKeys = Object.keys(this.props.actionConfig);
    const actionParts = actionKeys.map(actionName => (
      <Topology.Part
        id={controlName + "-" + actionName}
        status="ok"
        label={actionName}
        direction="row"
        demarcate={false}
        justify="start"
        align="center"
        key={featureName + "-" + actionName}
        className="raa_action"
        onClick={this.props.onClickItem}
        data-id={controlName + "-" + actionName}
        data-type="componentAction"
      />
    ));
    return (
      <Topology.Parts direction="column" uniform={true}>
        {actionParts}
      </Topology.Parts>
    );
  }
}

class RoboArmApp extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      roboarmConfig: null,
      move_command: { arm: 0b00000000, base: 0b00000000, light: 0b00000000 },
      clicked_items: CLICKED_ITEMS,
      command_links: []
    };
  }

  componentDidMount() {
    const api_url = window.location.protocol + "//" + window.location.hostname + ":" + window.location.port;
    fetch(api_url + "/config")
      .then(resp => resp.json())
      .then(data => {
        // derive initial topology links from config:
        // for each feature (excluding the "all" aggregate), link it to the default action
        // of the displayed control feature ("all" for multi-feature components, the feature itself otherwise)
        const links = [];
        Object.keys(data.components).forEach(compName => {
          const features = data.components[compName].features;
          const featureNames = Object.keys(features);
          const controlFeature = featureNames.length > 1 && featureNames.includes('all') ? 'all' : featureNames[0];
          const controlActions = Object.keys(features[controlFeature].actions);
          const defaultAction = controlActions.includes('stop') ? 'stop'
            : controlActions.includes('off') ? 'off'
            : controlActions[0];
          featureNames.filter(f => f !== 'all').forEach(featName => {
            links.push({
              colorIndex: "graph-2",
              ids: [compName + "-" + featName, compName + "-" + defaultAction],
              component: compName,
              feature: featName
            });
          });
        });
        this.setState({ roboarmConfig: data, command_links: links });
      })
      .catch(error => console.log("ERROR loading config: " + error));
  }

  update_links(component, feature, action) {
    let updated_link = false;
    let curr_links = this.state.command_links;

    for (let i = 0; i < curr_links.length; i++) {
      if (curr_links[i].component == component && curr_links[i].feature == feature) {
        curr_links[i].ids = [component + "-" + feature, component + "-" + action];
        updated_link = true;
      }
    }
    if (!updated_link) {
      curr_links.push({
        colorIndex: "graph-3",
        ids: [component + "-" + feature, component + "-" + action],
        component: component,
        feature: feature
      });
    }

    this.setState({ command_links: curr_links });
    this.invoke_api(component, feature, action);
  }

  invoke_api(component, feature, action) {
    const api_url = window.location.protocol + "//" + window.location.hostname + ":" + window.location.port;
    const api_path = "/roboarm/" + component + "/" + feature + "/" + action;
    console.log(api_url + api_path);
    fetch(api_url + api_path)
      .then(resp => resp.json())
      .then(data => {
        this.update_move_command(data);
        console.log("INFO: updated move command: " + data);
      })
      .catch(error => console.log("ERROR: " + error));
  }

  update_move_command(move_command_response) {
    this.setState({ move_command: move_command_response });
  }

  handle_mode_switch = event => {
    console.log(event.target.value);
  };

  command_click = event => {
    let clicked_componentfeature, clicked_componentaction, cl_parts;

    cl_parts = this.state.clicked_items;

    console.log("INFO: clicked element target data-type: " + event.currentTarget.dataset.type);
    console.log("INFO: clicked element target data-id: " + event.currentTarget.dataset.id);

    if (event.currentTarget.dataset.type == "componentFeature") {
      clicked_componentfeature = event.currentTarget.dataset.id.split("-");
      cl_parts[0].component = clicked_componentfeature[0];
      cl_parts[0].feature = clicked_componentfeature[1];
      console.log("INFO: clicked a feature: " + cl_parts[0].feature);
    } else if (event.currentTarget.dataset.type == "componentAction") {
      clicked_componentaction = event.currentTarget.dataset.id.split("-");
      cl_parts[1].component = clicked_componentaction[0];
      cl_parts[1].action = clicked_componentaction[1];
      console.log("INFO: clicked an action: " + cl_parts[1].action);
    } else {
      console.log("ERROR: something wasn't clicked right?");
    }

    if (cl_parts[0].component == cl_parts[1].component && cl_parts[0].component != "") {
      this.update_links(cl_parts[0].component, cl_parts[0].feature, cl_parts[1].action);
      // reset component so the last clicked action doesn't carry over to the next component
      cl_parts[1].component = "";
    }

    this.setState({ clicked_items: cl_parts });
  };

  render() {
    if (!this.state.roboarmConfig) {
      return <App><Box colorIndex="neutral-1" pad="medium">Loading...</Box></App>;
    }
    return (
      <App>
        <Box
          align="center"
          colorIndex="neutral-1"
          margin="medium"
          pad="small"
          direction="column"
        >
          <Box margin="medium">
            <CheckBox
              label="Live Mode"
              id="mode_switch"
              name="mode_switch"
              defaultChecked={true}
              onChange={this.handle_mode_switch}
              disabled={true}
            />
          </Box>
          <Box margin="medium">
            <img
              src={window.location.protocol + "//" + window.location.hostname + "/html/cam_pic_new.php"}
              alt="Live Feed"
            />
          </Box>
          <Box margin="medium">
            <Topology
              a11yTitle={this.state.roboarmConfig.description}
              links={this.state.command_links}
            >
              <Topology.Parts direction="column" uniform={true}>
                <Topology.Part direction="column">
                  <RoboArmComponents
                    componentConfig={this.state.roboarmConfig.components}
                    roboArmName={this.state.roboarmConfig.description}
                    onClickItem={this.command_click}
                  />
                </Topology.Part>
              </Topology.Parts>
            </Topology>
          </Box>
        </Box>
      </App>
    );
  }
}

var element = document.getElementById("content");
ReactDOM.render(<RoboArmApp />, element);
